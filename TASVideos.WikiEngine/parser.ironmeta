using System;
using System.Linq;

ironmeta Wiki<char, AST.INode>
{
	LineEnding = "\r\n" | "\r" | "\n";
	LineSeparatedAB :first :second = first (LineEnding second)? | second;

	InlineTextChild :texttype :excludes =
		Bold(texttype) | Emphasis(texttype) | Smaller(texttype) |
		Teletype(texttype) | Strikethrough(texttype) | Quote(texttype) |
		InlineBreak | InlineIf(texttype) | Module | LeftBracket | RightBracket | RawInlineText(excludes);

	Bold :texttype = "__" (~"__" texttype)*:a "__" -> { return MakeElt("b", a); };
	Emphasis :texttype = "''" (~"''" texttype)*:a "''" -> { return MakeElt("em", a); };
	Smaller :texttype = "((" texttype*:a "))" -> { return MakeElt("small", a); };
	Teletype :texttype = "{{" texttype*:a "}}" -> { return MakeElt("tt", a); };
	Strikethrough :texttype = "---" (~"---" texttype)*:a "---" -> { return MakeElt("del", a); };
	Quote :texttype = "««" texttype*:a "»»" -> { return MakeElt("q", a); };
	InlineBreak = "%%%" -> { return MakeElt("br"); };
	InlineIf :texttype = "[if:" ModuleText:c "]" texttype*:a "[endif]" -> { return MakeIf(c, a); };
	Module = "[" ~"endif" ModuleText:a "]" -> { return MakeModule(a); };
		ModuleText = (~('\r' | '\n' | '[' | ']').)*:a -> { return MakeText(a); };
	LeftBracket = "[[" -> { return MakeText("["); };
	RightBracket = "]]" -> { return MakeText("]"); };
	RawInlineText :excludes = InlineChar(excludes)+:a -> { return MakeText(a); };
	InlineChar :excludes = ~('\r' | '\n' | '\0' | '_' | '\'' | '(' | ')' | '{' | '}' | '«' | '»' | '-' | '%' | '[' | ']' | excludes). |
		'_' ~'_' |
		'\'' ~'\'' |
		'(' ~'(' |
		')' ~')' |
		'{' ~'{' |
		'}' ~'}' |
		'«' ~'«' |
		'»' ~'»' |
		'-' ~"--" |
		'%' ~"%%";

	// text within a paragraph
	PText = InlineTextChild(PText, '\0') | PLineEnding;
	PLineEnding = LineEnding ~('>' | ' ' | '*' | '#' | ';' | '!' | '|' | "----" | "%%" | "[if:" | "[endif]" | LineEnding) -> { return MakeText("\n"); };

	// text within a blockquote
	KText = InlineTextChild(KText, '\0') | KLineEnding;
	KLineEnding = LineEnding ">" -> { return MakeText("\n"); };

	// text within a pre
	PreText = InlineTextChild(PreText, '\0') | PreLineEnding;
	PreLineEnding = LineEnding " " -> { return MakeText("\n"); };

	// text constrainted to a single LineEnding
	IText = InlineTextChild(IText, '\0');

	// text missing a colon; for TermList
	TermText = InlineTextChild(TermText, ':');

	// text missing a pipe; for Tables
	TableText = InlineTextChild(TableText, '|');

	// allowed at the top level or within certain nested items
	DocumentFragmentItem =
		List | TermList | Toc | Table | SrcEmbed | MultiQuote | Div | HTabs | VTabs | BlockIf | HorizontalRule |
		Heading | BlockQuote | Preformatted | Paragraph | EmptyLine;
	// allowed at the top level
	DocumentItem = ImplicitVTabs | DocumentFragmentItem;

	// items that can contain nested document fragments
	NestedNormal :start :end :tag :attr =
		start ClassText:a LineEnding (DocumentItem LineEnding)*:b end -> { return MakeElt(Str(tag), b, Attr(Str(attr), a)); } |
		start LineEnding (DocumentItem LineEnding)*:b end -> { return MakeElt(Str(tag), b); };
	ClassText = ' ' (~('\r' | '\n').)+:a -> { return MakeText(a); };
	MultiQuote = NestedNormal("%%QUOTE", "%%QUOTE_END", "quote", "data-author");
	Div = NestedNormal("%%DIV", "%%DIV_END", "div", "class");
	TabBase :start :navclass :tabclass = start Tab+:a "%%TAB_END%%" -> { return MakeTabs(Str(navclass), Str(tabclass), a); };
		Tab = "%%TAB " TabName:a "%%"? LineEnding (DocumentFragmentItem LineEnding)*:b -> { return MakeElt("tab", b, Attr("name", a)); };
			TabName = (~('\r' | '\n' | '%').)+:a -> { return MakeText(a); };
	HTabs = TabBase("%%TAB_HSTART%%" LineEnding, "nav nav-pills nav-stacked col-md-3", "tab-content col-md-9");
	VTabs = TabBase("%%TAB_START%%" LineEnding, "nav nav-tabs", "tab-content");
	ImplicitVTabs = TabBase("", "nav nav-tabs", "tab-content");
	BlockIf = "[if:" ModuleText:c "]" LineEnding (DocumentItem LineEnding)*:a "[endif]" -> { return MakeIf(c, a); };

	// items that consume one line
	HorizontalRule = "---" "-"+ -> { return MakeElt("hr"); };
	Heading = "!"{1,4}:a IText*:b -> { return MakeElt("h" + (5 - a.Inputs.Count()), b); };
	Toc = "%%TOC%%" -> { return MakeElt("toc"); };
	// UnknownDirective = "%%" DirectiveText:a -> { return MakeElt("directive", a); };
	//	DirectiveText = (~('\r' | '\n').)*:a -> { return MakeText(a); };
	EmptyLine = "";

	// items that consume multiple lines
	List = DeeperList("");
		DeeperList :prefix = ListBase(prefix '*', "ul") | ListBase(prefix '#', "ol");
		ListBase :prefix :tag = ListItem(prefix) (LineEnding ListItem(prefix))* -> { return MakeElt(Str(tag), _IM_Result); };
		ListItem :prefix = &prefix LineSeparatedAB(prefix IText*, DeeperList(prefix)) -> { return MakeElt("li", _IM_Result); };
	Table = LineSeparatedAB(TableHead, TableBody) -> { return MakeElt("table", _IM_Result); };
		TableHead = TableHeadRow (LineEnding TableHeadRow)* -> { return MakeElt("thead", _IM_Result); };
			TableHeadRow = "||" (HeadCell "||")*:a -> { return MakeElt("tr", a); };
				HeadCell = TableText*:a -> { return MakeElt("th", a ); };
		TableBody = TableBodyRow (LineEnding TableBodyRow)* -> { return MakeElt("tbody", _IM_Result); };
			TableBodyRow = '|' (BodyCell '|')*:a -> { return MakeElt("tr", a); };
				BodyCell = TableText*:a -> { return MakeElt("td", a ); };
	TermList = TermLine (LineEnding TermLine)* -> { return MakeElt("dl", _IM_Result); };
		TermLine = ';' TermText*:a ':' IText*:b -> { return new[] { MakeElt("dt", a), MakeElt("dd", b) }; };
	SrcEmbed = "%%SRC_EMBED" SrcSyntax:a LineEnding SrcText?:b LineEnding "%%END_EMBED" -> { return MakeElt("code", b, Attr("data-syntax", a)); };
	SrcEmbed = "%%SRC_EMBED" LineEnding SrcText?:b LineEnding "%%END_EMBED" -> { return MakeElt("code", b); };
		SrcSyntax = ' ' (~('\r' | '\n').)+:a -> { return MakeText(a); };
		SrcText = (~(LineEnding "%%END_EMBED").)+:a -> { return MakeText(a); };
	BlockQuote = ">" KText*:a -> { return MakeElt("blockquote", a); };
	Preformatted = " " PreText*:a -> { return MakeElt("pre", a); };
	Paragraph = ~(LineEnding | ("%%" ~'%') | "[if:" | "[endif]") PText+:a -> { return MakeElt("p", a); };

	Document = DocumentItem (LineEnding DocumentItem)* LineEnding?;
}
